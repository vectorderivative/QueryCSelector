using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using System.Xml.XPath;
using System.Text;
using System.Threading.Tasks;

using System.Diagnostics;

namespace XML2DB
{
    /// <summary>
    /// Selector de nodos XML, al estilo JQuery. Acepta expresiones XPATH como selectores.
    /// </summary>
    /// <remarks>Los selectores deben ser expresiones XPATH. A cada selector se le agrega al inicio <code>//</code> para buscar en todo el documento, no es necesario usarlo en el selector
    /// La búsqueda ignora los namespaces
    /// </remarks>
    public class QuerySelector
    {
        private XElement x;
        private IEnumerable<XElement> xs;

        /// <summary>
        /// Crea el objeto a partir de una cadena XML
        /// </summary>
        /// <param name="code">String XML</param>
        /// <returns>Referencia a si mismo</returns>
        public QuerySelector Create(string code)
        {
            try
            {
                x = XElement.Parse(code, LoadOptions.None);

                Debug.WriteLine("Cargado cadena " + code);
            }
            catch (System.Xml.XmlException e)
            {
                Debug.WriteLine(e.Message);
            }
            
            return this;
        }

        /// <summary>
        /// Crea el objeto a apartir de un objeto XElement
        /// </summary>
        /// <remarks>Método útil para generar nuevos objetos a partir de las búsquedas de nodos, ya que estas regresan un objeto XElement o una colección de los mismos.
        /// Cada búsqueda genera una nueva instancia de QuerySelector con la selección para asi poder trabajar sobre ella, para eso es útil este método.
        /// </remarks>
        /// <param name="el">XElement nodo</param>
        /// <returns>Referencia a si mismo</returns>
        public QuerySelector Create(XElement el)
        {
            x = el;
            return this;
        }

        /// <summary>
        /// Crea el objeto a apartir de una colección de XElement
        /// </summary>
        /// <param name="els">IEnumerable XElement nodos</param>
        /// <returns>Referencia a si mismo</returns>
        public QuerySelector Create(IEnumerable<XElement> els)
        {
            xs = els;
            return this;
        }

        /// <summary>
        /// Carga XML desde un archivo en disco
        /// </summary>
        /// <param name="url">String locación</param>
        /// <returns>Referencia a si mismo</returns>
        public QuerySelector CreateFromFile(string url)
        {
            try
            {
                x = XElement.Load(url);

                Debug.WriteLine("Cargado QS de archivo " + url);
            }
            catch (System.Xml.XmlException e)
            {
                Debug.WriteLine(e.Message);
            }
            
            return this;
        }

        /// <summary>
        /// Regresa una instancia de QuerySelector con el nodo <code>i</code> de una selección hecha
        /// </summary>
        /// <remarks>Si se llama sobre una colección de un solo nodo carga ese nodo sin importar el índice</remarks>
        /// <param name="i">int Índice</param>
        /// <returns>QuerySelector</returns>
        public QuerySelector GetElement(int i)
        {
            QuerySelector QS = new QuerySelector();
            if (xs != null) {
                QS.Create(xs.ElementAt<XElement>(i));
            }
            else
            {
                QS.Create(x);
            }
            return QS; 

            /*if (xs != null)
            {
                this.x = xs.ElementAt<XElement>(i);
            }

            return this;*/
        }

        /// <summary>
        /// Si se llama sobre una colección de varios nodos carga el primero, si se llama sobre un solo nodo carga este en un nuevo QuerySelector y lo regresa.
        /// </summary>
        /// <returns>QuerySelector</returns>
        public QuerySelector GetElement()
        {
            QuerySelector QS = new QuerySelector();

            if (x != null)
            {
                QS.Create(x);
            }
            else
            {
                QS.Create(xs.First<XElement>());
            }
            return QS;
            /*if (x == null && xs != null)
            {
                this.x = xs.First<XElement>();
            }

            return this;*/
        }

        /// <summary>
        /// Regresa el número de nodos que fueron encontrados en la selección
        /// </summary>
        /// <returns>int length</returns>
        public int Length()
        {
            int i = 0;
            if (xs != null)
            {
                foreach (XElement item in xs)
                {
                    i++;
                }
            }
            if (x != null)
            {
                i = 1;
            }

            return i;
        }

        /// <summary>
        /// Realiza la búsqueda XPATH indicada por <code>selector</code> y regresa un nuevo objeto QuerySelector con los nodos resultantes.
        /// </summary>
        /// <remarks>Todos los métodos actuán sobre el resultado de este método. Ej: <code>QS.Select("nodo1/nodoHijo").length()</code> Obtiene el número de ocurrencias de la búsqueda</remarks>
        /// <param name="selector">String XPath Expression</param>
        /// <returns>QuerySelector</returns>
        public QuerySelector Select(String selector)
        {
            StringBuilder newSelector = new StringBuilder();
            QuerySelector QS = new QuerySelector();

            /*Eliminar la necesidad de especificar namespaces en el selector*/
            //Se separa cada nodo en la expresión para poder reescribirla solicitando sólo en nombre del nodo sin namespace
            if (selector.IndexOf("/") > 0)
            {
                var selectors = selector.Split('/');

                for (int i = 0; i < selectors.Length; i++)
                {
                    if (i == 0)
                    {
                        //Si es el nodo padre, se agrega // para que la búsqueda sea en todo documento
                        newSelector.Append("//*[local-name()='").Append(selectors[i]).Append("']");
                    }
                    else
                    {
                        newSelector.Append("/*[local-name()='").Append(selectors[i]).Append("']");
                    }
                }

                //No recuerdo si esto tuvo alguna utilidad...
                foreach (var item in selectors)
                {
                    newSelector.Append("");
                }
            }
                //Sólo se busca un sólo nodo, no hay necesidad de recorrer nada
            else
            {
                newSelector.Append("//*[local-name()='").Append(selector).Append("']");
            }

            if (x != null)
            {
                //this.xs = x.XPathSelectElements(newSelector.ToString());

                //Se crea un nuevo objeto con la selección hecha sobre "x" que contiene el XML cargado
                var selectedNode = x.XPathSelectElements(newSelector.ToString());
                
                //En la especificación XML el elemento raíz no cuenta como un nodo. Si se busca el nodo, este no existe.
                //Se debe buscar con una expresión XPath que se refiera a la raíz (/), en el caso de raíz sin namespace
                //se utiliza la expresión local-name(/)
                if (selectedNode.Count() == 0 ) {
                    if (selector.Equals(x.XPathEvaluate("local-name(/)")))
                    {
                        selectedNode = x.XPathSelectElements("/");
                    }
                }

                QS.Create(selectedNode);
            }
            else
            {
                //this.xs = xs.First<XElement>().XPathSelectElements(newSelector.ToString());
                //Si la selección se intenta hacer sobre una colección de XMLs, que solamente se haga con el primer elemento.
                var selectedNode = xs.First<XElement>().XPathSelectElements(newSelector.ToString());

                if (selectedNode.Count() == 0) {
                    if (selector.Equals(xs.First<XElement>().XPathEvaluate("local-name(/*)")))
                    {
                        selectedNode = x.XPathSelectElements("/");
                    }
                }

                QS.Create(selectedNode);
            }

            return QS;
        }

        /// <summary>
        /// Regresa el valor del nodo seleccionado por <code>Select</code>
        /// </summary>
        /// <remarks>Si no existe selección debe regresar NULL para que el traductor pueda lidiar bien con nodos inexistentes o vacíos</remarks>
        /// <returns>String contenido del nodo</returns>
        public string Text()
        {
            string value = "";

            if (xs != null)
            {
                try {
                    value = xs.FirstOrDefault<XElement>().Nodes().OfType<XText>().First().Value;
                }
                catch(Exception e)
                {
                    value = null;
                    Debug.WriteLine(e.Message);
                }
            }
            else
            {
                value = x.Nodes().OfType<XText>().First().Value;
            }

            /*if (value == null)
            {
                value = " ";
                Debug.WriteLine("El elemento no tiene contenido o no se pudo obtener");
            }*/
            /*if (String.IsNullOrEmpty(value))
            {
                if (xs != null)
                {
                    var textNode = xs.Nodes().OfType<XText>().FirstOrDefault();

                    if (textNode != null)
                    {
                        value = textNode.Value;
                    }
                }
                else
                {
                    var textNode = x.Nodes().OfType<XText>().FirstOrDefault();
                    if (textNode != null)
                    {
                        value = textNode.Value;
                    }
                }
            }*/

            return value;
        }

        /// <summary>
        /// Asigna una valor al nodo seleccionado por <code>Select</code>
        /// </summary>
        /// <param name="text">String valor</param>
        /// <returns>Referencia a si mismo</returns>
        public QuerySelector Text(string text)
        {
            if (xs != null)
            {
                //try
                //{
                    xs.First<XElement>().SetValue(text);
                //}
                /*catch (Exception e)
                {
                    x.SetValue(text);
                    Debug.WriteLine("Asignar texto exception: " + e.Message);
                }*/
            }
            else
            {
                x.SetValue(text);
            }

            return this;
        }

        /// <summary>
        /// Regresa un diccionario con los atributos y sus valores.
        /// </summary>
        /// <returns>Dictionary string,string</returns>
        public Dictionary<string,string> Attr()
        {
            IEnumerable<XAttribute> attributes;
            Dictionary<string,string> attributesDict = new Dictionary<string, string>();

            //Obtiene los atributos, ya sea un solo XML o una colección, en caso de que sea colección sólo toma el primer elemento
            if (xs != null)
            {
                attributes = xs.First<XElement>().Attributes();
            }
            else
            {
                attributes = x.Attributes();
            }

            foreach (var item in attributes)
            {
                attributesDict.Add(item.Name.ToString(), item.Value.ToString());
            }

            return attributesDict;
        }

        /// <summary>
        /// Asignar un atributo y su valor al nodo seleccionado con <code>Select</code>
        /// </summary>
        /// <param name="attibute" >String atributo</param>
        /// <param name="value">String valor</param>
        /// <returns>Referencia a si mismo</returns>
        public QuerySelector Attr(string attibute, string value)
        {
            if (xs != null)
            {
                xs.First<XElement>().SetAttributeValue(attibute, value);
            }
            else
            {
                x.SetAttributeValue(attibute, value);
            }

            return this;
        }

        public bool Contains(string element)
        {
            /*if (xs != null)
            {
                return xs.Elements<XElement>(element).Any<XElement>();
            }
            else
            {
                //return x.Descendants(element).Any();
                return x.Elements(element).Any();
            }*/
            return true;
        }

        /// <summary>
        /// Retorna el XML resultante
        /// </summary>
        /// <returns>String XML</returns>
        public string Render()
        {
            return this.x.ToString();
        }

    }
}
